// =====================================================
// WifiDisplay.cpp
//
// See rights and use declaration in License.h
//
// **** by Richard Benear 3/21/2025 ****
// Functions to support the capture of the SPI data to the TFT into buffer
// and then forward to external ESP32-S3 to be sent wirelessly to web page.
// Essentially, a WiFi screen mirror.
//
// Cleaned up some of the extraneous comments and added a faster drawRect().
// Added ability to capture the pixels going to each screen of the TFT into
// a RAM buffer and then store each screen file on the SD Flash. The
// SD flash can then be read by a python script "TftCapture/display_sd_image.py"
// which converts the color format to viewable .png files. These screen images
// are much more readable and representative of what is actually seen on the
// TFT. This was done primarily for documentation because the ones that were
// generated by taking photos of the handheld TFT display had too much backlight
// glow.

// **** Modified By Richard Benear 4/22/2025 *****
// Added a WiFi TFT Screen Mirror (WiFi Hand Controller) primarily because I
// wanted to use my iPhone to control the telescope and still use all my screens.
// (OnStep has a webpage but uses it's own screen setup and a LX200 command method.)
// Captured pixels that are written to the TFT in parallel are writen to a
// uncompressed buffer in PSRAM memory. DMAMEM is only 512K and full frame of Raw image
// is 307600 bytes. After trying to get both the uncompressed and compressed images
// into DMAMEM while trying various compression methods and running out of memory,
// I decided to add the 8MB PSRAM to the Teensy board. The buffers are sent via Host
// USB on the Teensy to an ESP32-S3 USB Device port. Originally, I tried a 1 Mbaud
// serial connection to a ESP32-C3 but keeping the UARTS from dropping bytes was difficult.
// I considered software based flow control with RTS/CTS but the USB is much "cleaner".
// To get the USB stack/library to fit into base Teensy RAM, I had to move the large
// Custom Catalog 2D arrays into EXTMEM. The compressed buffer sent to the ESP32-S3 is
//  then served to a webpage where it is decompressed. Various compression methods were
// tried (RLE, Difference pixels, LZ4, and Deflate). LZ4 comressed 307600 bytes to typically
// 25 KB to 43 KB or about 7:1 compression ratio for the images that are sent to the TFT.
// Deflate is much better and typical compressed images are around 9 KB or 35:1. Transfer time
// with USB 12Mbit/sec is about 70 msec. Difference encoding compression was even
// smaller but was unreliable, took more memory, and was complex. Update rate for the
// TFT is 1 sec as is the WiFi TFT Mirror so Deflate is the default mode since it is
// plenty fast.

#include <Arduino.h>
#include "WifiDisplay.h"
#include "../display/Display.h"
#include "../display/UsbBridge.h"
#include "miniz.h"
#include "src/lib/tasks/OnTask.h"
#include <Arduino.h>
#include <SD.h>

#define ACK 0x06
#define NACK 0x15

// DMAMEM is 512KB or not big enough, using PSRAM
// PSRAM is 8 MB
EXTMEM uint8_t compressedBuffer[COMPRESSED_BUFFER_SIZE];
EXTMEM uint8_t uncompressedBuffer[UNCOMPRESSED_BUFFER_SIZE];

volatile bool espReady = false;

// States
enum TeensyCommState {
  WAIT_FOR_HELLO_ACK,
  WAIT_FOR_IP,
  WAIT_FOR_IP_ACK,
  WAIT_FOR_CLIENT_CONNECTED,
  WAIT_FOR_ESP_RECEIVED_TYPE_ACK,
  WAIT_FOR_ESP_RECEIVED_SIZE_ACK,
  WAIT_FOR_ESP_RECEIVED_FRAME_ACK,
  ERROR
};

TeensyCommState teensyState = WAIT_FOR_HELLO_ACK;

// =================================================================

// *** Functions to enable capture a screen and redirect it to WiFi *****
void WifiDisplay::enableScreenCapture(bool enable) {
  if (isScreenCaptureEnabled) {
    //memset(uncompressedBuffer, 0, COMPRESSED_BUFFER_SIZE);
  }
  isScreenCaptureEnabled = enable;
}

// ACK handler
bool waitForEspACK(unsigned long timeoutMillis) {
  unsigned long ackTime = millis();

  while (millis() - ackTime < timeoutMillis) {
    if (SERIAL_ESP.available()) {
      char incoming = SERIAL_ESP.read();
      if (incoming == ACK) {
        return true;
      }
    }
    yield();
  }
  return false; // Timed out
}

// ==================== Deflate Compression ====================
size_t WifiDisplay::compressWithDeflate() {
  memset(compressedBuffer, 0, COMPRESSED_BUFFER_SIZE);

  mz_stream stream = {0};
  stream.next_in = uncompressedBuffer;
  stream.avail_in = UNCOMPRESSED_BUFFER_SIZE;
  stream.next_out = compressedBuffer;
  stream.avail_out = COMPRESSED_BUFFER_SIZE;

  // Use mz_deflateInit2 with negative windowBits to get raw deflate
  int status = mz_deflateInit2(&stream, MZ_DEFAULT_COMPRESSION, MZ_DEFLATED,
                               -MZ_DEFAULT_WINDOW_BITS, 9, 0);
  if (status != MZ_OK) {
    SERIAL_DEBUG.println("Deflate init failed");
    return 0;
  }

  status = mz_deflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END) {
    SERIAL_DEBUG.println("Deflate compression failed");
    mz_deflateEnd(&stream);
    return 0;
  }

  size_t compressedSize = stream.total_out;
  mz_deflateEnd(&stream);

  // SERIAL_DEBUG.printf("Deflated %u -> %u bytes\n", UNCOMPRESSED_BUFFER_SIZE,
  //               compressedSize);

  return compressedSize;
}

// ==================== RLE Compression Function ====================
// This function implements a Run-Length Encoding (RLE) compression algorithm
// tailored for 16-bit RGB565 pixel data. It compresses a framebuffer of
// uncompressed RGB565 pixels (stored in uncompressedBuffer) and writes the
// compressed data to compressedBuffer. It reads a 16-bit pixel from the
// uncompressedBuffer, treating it as big-endian (high byte first), unless
// USE_LITTLE_ENDIAN is defined. It then loop to find how many times the current
// pixel repeats consecutively in the buffer (up to a max of 255, since the run
// length is stored in 1 byte). Depending on endian mode: Big-endian stores the
// pixel as [highByte][lowByte]. Then stores the runLength as 1 byte. Each
// encoded segment uses 3 bytes to represent: A 16-bit RGB565 color and a repeat
// count (1â€“255)
// =================== RLE Compression ============================
size_t WifiDisplay::compressWithRLE() {
  size_t writeIndex = 0;
  size_t readIndex = 0;

  while (readIndex < UNCOMPRESSED_BUFFER_SIZE) {
    uint16_t currentPixel = (uncompressedBuffer[readIndex] << 8) |
                            uncompressedBuffer[readIndex + 1];

    size_t runLength = 1;
    readIndex += 2;

    while (readIndex < UNCOMPRESSED_BUFFER_SIZE && runLength < 255) {
      uint16_t nextPixel = (uncompressedBuffer[readIndex] << 8) |
                           uncompressedBuffer[readIndex + 1];

      if (nextPixel != currentPixel)
        break; // end of normal color run
      runLength++;
      readIndex += 2;
    }

    if (writeIndex + 3 > COMPRESSED_BUFFER_SIZE) {
      SERIAL_DEBUG.println("ERROR: Compressed buffer overflow.");
      return 0;
    }
    // Write RLE: big endian color + run length
    compressedBuffer[writeIndex++] = (currentPixel >> 8) & 0xFF;
    compressedBuffer[writeIndex++] = currentPixel & 0xFF;
    compressedBuffer[writeIndex++] = runLength;
  }
  // SERIAL_DEBUG.print("Compressed Size: ");
  // SERIAL_DEBUG.println(writeIndex);
  return writeIndex;
}

// Teensy4.1 and ESP32-S3 both have handshake State Machines
// ============== State Flow ===============================
// Command	         Byte	     Meaning
// HELLO	           'H'	   Teensy says "I'm alive"
// HELLO_ACK	       'A'	   ESP32 says "I hear you"
// IP_START	         'I'	   ESP32 sends IP address (e.g., I192.168.1.55\n)
// CLIENT_CONNECTED  'X'	   ESP says: Client is connected
// ACK	             'K'	   Teensy acknowledgement
// RESET	           'R'	   From ESP: Reset whole state machine
// ==> BOTH are READY, Teensy can send frames
// RESET ESP32 FRAME 'Z'     From Teensy to ESP32 

// ======== Teensy to ESP communication State Machine ========
void WifiDisplay::espPoll() {
  if (SERIAL_ESP.available()) {
    char isItReset = SERIAL_ESP.peek();
    if (isItReset == 'R') {
      SERIAL_ESP.read(); // consume it
      Serial.println("Received reset signal 'R'");
      espReady = false;
      teensyState = WAIT_FOR_HELLO_ACK;
      return;
    }
  }
  
  if (!espReady && SERIAL_ESP.available()) {
    char peekChar = SERIAL_ESP.peek();
    // Touch is running in different RTOS process and timing
    if (peekChar == 'T') return;

    char incoming = SERIAL_ESP.read();

    switch (teensyState) {
    case WAIT_FOR_HELLO_ACK:
      if (incoming == 'A') {
        SERIAL_DEBUG.println("Got HELLO_ACK");
        teensyState = WAIT_FOR_IP;
        SERIAL_ESP.write('I');
        SERIAL_ESP.flush();
      }
    break;

    case WAIT_FOR_IP:
      if (incoming == 'I') {
        String ipStr = "";
        while (SERIAL_ESP.available()) {
          char c = SERIAL_ESP.read();
          if (c == '\n')
            break;
          ipStr += c;
        }
        SERIAL_DEBUG.print("IP Address: ");
        SERIAL_DEBUG.println(ipStr);
        if (display.currentScreen == HOME_SCREEN) {
          tft.fillRect(170, 300, 140, 20, butBackground); // Clear old IP area
          tft.setCursor(170, 312);
          tft.print("I");
          tft.print(ipStr);
        }
        delay(1);
        SERIAL_ESP.write('K'); // IP ACK
        SERIAL_ESP.flush();
        teensyState = WAIT_FOR_CLIENT_CONNECTED;
      }
    break;
 
    case WAIT_FOR_CLIENT_CONNECTED:
      if (incoming == 'X') {
        SERIAL_DEBUG.println("Web Client Connected");
        SERIAL_ESP.write('K'); // Client Connect ACK
        SERIAL_ESP.flush();
        espReady = true;
        teensyState = WAIT_FOR_ESP_RECEIVED_TYPE_ACK;
      } else if (incoming == 'I') {
        String ipStr = "";
        while (SERIAL_ESP.available()) {
          char c = SERIAL_ESP.read();
          if (c == '\n')
            break;
          ipStr += c;
        }
        SERIAL_DEBUG.print("IP Address: ");
        SERIAL_DEBUG.println(ipStr);
        delay(1);
        SERIAL_ESP.write('K'); // IP ACK
        SERIAL_ESP.flush();
        espReady = false;
        teensyState = WAIT_FOR_CLIENT_CONNECTED;
      } else {
        espReady = false;
        teensyState = WAIT_FOR_HELLO_ACK;
      }
    break;

    default:
    break;
    }
  }

  // Periodically send HELLO if needed
  if (!espReady && teensyState == WAIT_FOR_HELLO_ACK) {
    static unsigned long lastHelloTime = 0;
    if (millis() - lastHelloTime > 1000) {
      SERIAL_DEBUG.println("Sending HELLO...");
      SERIAL_ESP.write('H');
      SERIAL_ESP.flush();
      lastHelloTime = millis();
    }
  }
}

// Z (0x5A)= Reset ESP32-S3 state
// T (0x54)= Touch
// ================ Send Buffer =================================
void WifiDisplay::sendFrameToEsp(uint8_t frameType) {
  if (!espReady) {
    SERIAL_DEBUG.println("ESP not ready");
    return;
  }
  // Check if any status byte is available from ESP
  if (SERIAL_ESP.available()) {
    char peekChar = SERIAL_ESP.peek();
    //SERIAL_DEBUG.print(peekChar);
    if (peekChar == 'T' || 'R') return;
  }
  
  //long startTime = millis();
   // Reset the ESP32 frame state
   //SERIAL_DEBUG.println("Sending 'Z'");
   SERIAL_ESP.write('Z');
   SERIAL_ESP.flush();
   delay(1);
   
  // clear any junk
  while (SERIAL_ESP.available()) {
    SERIAL_ESP.read();
  }
  
  // === Prepare Size of Payload ===
  size_t bufSize = 0;
  const uint8_t *bufferToSend = nullptr;

  if (frameType == FRAME_TYPE_RLE) {
    bufSize = compressWithRLE();
    if (bufSize == 0)
      return;
    bufferToSend = compressedBuffer;
    // SERIAL_DEBUG.println("Sending RLE frame to ESP32-S3");
  } else if (frameType == FRAME_TYPE_DEF) {
    bufSize = compressWithDeflate();
    if (bufSize == 0)
      return;
    bufferToSend = compressedBuffer;
    //SERIAL_DEBUG.println("Sending Deflate frame to ESP32-S3");
  } else if (frameType == FRAME_TYPE_RAW) {
    bufSize = UNCOMPRESSED_BUFFER_SIZE;
    bufferToSend = uncompressedBuffer;
  } else {
    SERIAL_DEBUG.printf("Unknown FRAME TYPE");
  }

  //SERIAL_DEBUG.printf("Sending bufSize (%u bytes) as [0x%02X 0x%02X 0x%02X 0x%02X]\n",
  //  bufSize,
  //  (uint8_t)(bufSize & 0xFF),
  //  (uint8_t)((bufSize >> 8) & 0xFF),
  //  (uint8_t)((bufSize >> 16) & 0xFF),
  //  (uint8_t)((bufSize >> 24) & 0xFF)
  //);

  // === Send Type and Size Header ===
  SERIAL_ESP.write(frameType);
  SERIAL_ESP.write((uint8_t)(bufSize & 0xFF));
  SERIAL_ESP.write((uint8_t)((bufSize >> 8) & 0xFF));
  SERIAL_ESP.write((uint8_t)((bufSize >> 16) & 0xFF));
  SERIAL_ESP.write((uint8_t)((bufSize >> 24) & 0xFF));
  SERIAL_ESP.flush();
  delay(1);

  // === Wait for ACK ===
  if (!waitForEspACK(2000)) {
    SERIAL_DEBUG.println("ESP32 header processing timeout. Aborting transfer.");
    espReady = false;
    return;
  }
  //SERIAL_DEBUG.println("Got buffer size ACK");

  // --- Send Payload in 64-byte Chunks with Flow Control ---
  int totalSent = 0;
  const size_t packetSize = 64;

  for (size_t i = 0; i < bufSize; i += packetSize) {
    int chunkSize = min(packetSize, bufSize - i);

    // Wait until there's space to send the next chunk
    while (SERIAL_ESP.availableForWrite() < chunkSize) {
      yield(); // Let background USB and other tasks run (required for correct operation)
    }

    int sent = SERIAL_ESP.write(bufferToSend + i, chunkSize);
    totalSent += sent;
    delayMicroseconds(100); // Tune this if needed
  }
  SERIAL_ESP.flush();
  //SERIAL_DEBUG.println("Got frame sent ACK");

  //unsigned long elapsed = millis() - startTime;
  //SERIAL_DEBUG.printf("Sent %d bytes in %d ms\n", totalSent, elapsed);
  // NOTE: the longest elapsed time to compress and send is approx 143 msec.
}

// ==================== Save Buffer to SD Card ====================
void WifiDisplay::saveBufferToSD(const char *screenName) {
  // Build the file name based on the screen name
  char fileName[64];
  snprintf(fileName, sizeof(fileName), "/tft_%s_log.bin", screenName);

  // Remove the file if it already exists
  if (SD.exists(fileName)) {
    SD.remove(fileName); // Delete the file to ensure it's completely erased
  }

  // Open the file for writing (overwrite existing file)
  File logFile = SD.open(fileName, (uint8_t)(O_WRITE | O_CREAT));
  if (logFile) {
    // logFile.write(uncompressedBuffer, UNCOMPRESSED_BUFFER_SIZE);
    SERIAL_DEBUG.print("File size: ");
    SERIAL_DEBUG.println(logFile.size());
    logFile.close();
    SERIAL_DEBUG.print("Buffer saved to SD card as: ");
    SERIAL_DEBUG.println(fileName);
  } else {
    SERIAL_DEBUG.println("Failed to open file for writing.");
  }
  // Clear the buffer (Overwrite with zeros)
  memset(uncompressedBuffer, 0, UNCOMPRESSED_BUFFER_SIZE);
}

